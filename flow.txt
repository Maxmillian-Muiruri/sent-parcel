Project setup & folder structure
Auth module (login, register, guards)
User module (dashboard, send parcel, tracking, notification center)
Admin module (dashboard, manage parcels, assign courier)
Courier module (dashboard, update location/status)
Shared module (dynamic message, pipes, directives)
State management (ngRx) and dummy data services
Google Maps integration
Search, pagination, and UI polish
Why Add Geocoding?


Summary Table
Step	What to Do	Example File(s)
1	Define interfaces/models	shared/models/parcel.model.ts
2	Create services with mock data	shared/services/parcel.service.ts
3	Use services in components	admin-dashboard.ts, etc.
4	Implement modals for all CRUD operations	modal.component.ts, etc.
5	Filter data by role in components	courier-dashboard.ts, etc.
6	Simulate all flows (admin, courier, user)	All dashboard components
7	Add UI feedback (loading, errors)	All components
8	(Optional) Add state management (ngRx)	state/
9	Swap mock for real API when backend is ready	Update service methods



backend folder structure and 
the flow 
sendit-backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ auth/                                   # Authentication logic (login, register, JWT)
â”‚   â”‚   â”œâ”€â”€ auth.controller.ts                  # Handles HTTP requests for authentication (login, register)
â”‚   â”‚   â”œâ”€â”€ auth.module.ts                      # NestJS module definition for auth
â”‚   â”‚   â”œâ”€â”€ auth.service.ts                     # Business logic for authentication (validate user, issue tokens)
â”‚   â”‚   â”œâ”€â”€ strategies/
â”‚   â”‚   â”‚   â””â”€â”€ jwt.strategy.ts                 # JWT strategy for validating tokens
â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚       â”œâ”€â”€ login.dto.ts                    # Data Transfer Object for login validation
â”‚   â”‚       â””â”€â”€ register.dto.ts                 # Data Transfer Object for registration validation
â”‚   â”‚
â”‚   â”œâ”€â”€ users/                                  # User management (CRUD, profile, roles)
â”‚   â”‚   â”œâ”€â”€ users.controller.ts                 # Handles HTTP requests for user operations
â”‚   â”‚   â”œâ”€â”€ users.module.ts                     # NestJS module definition for users
â”‚   â”‚   â”œâ”€â”€ users.service.ts                    # Business logic for user operations
â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚       â”œâ”€â”€ create-user.dto.ts              # DTO for creating a user
â”‚   â”‚       â”œâ”€â”€ update-user.dto.ts              # DTO for updating user info
â”‚   â”‚       â””â”€â”€ user-response.dto.ts            # DTO for formatting user responses
â”‚   â”‚
â”‚   â”œâ”€â”€ parcels/                                # Parcel management (CRUD, status, assignment)
â”‚   â”‚   â”œâ”€â”€ parcels.controller.ts               # Handles HTTP requests for parcel operations
â”‚   â”‚   â”œâ”€â”€ parcels.module.ts                   # NestJS module definition for parcels
â”‚   â”‚   â”œâ”€â”€ parcels.service.ts                  # Business logic for parcel operations
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”œâ”€â”€ create-parcel.dto.ts            # DTO for creating a parcel
â”‚   â”‚   â”‚   â”œâ”€â”€ update-parcel.dto.ts            # DTO for updating parcel info
â”‚   â”‚   â”‚   â”œâ”€â”€ update-status.dto.ts            # DTO for updating parcel status
â”‚   â”‚   â”‚   â””â”€â”€ assign-courier.dto.ts           # DTO for assigning a courier to a parcel
â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚       â””â”€â”€ parcel.entity.ts                # (Optional) Entity class for parcel (if needed for serialization)
â”‚   â”‚
â”‚   â”œâ”€â”€ couriers/                               # Courier management (CRUD, location updates)
â”‚   â”‚   â”œâ”€â”€ couriers.controller.ts              # Handles HTTP requests for courier operations
â”‚   â”‚   â”œâ”€â”€ couriers.module.ts                  # NestJS module definition for couriers
â”‚   â”‚   â”œâ”€â”€ couriers.service.ts                 # Business logic for courier operations
â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚       â”œâ”€â”€ create-courier.dto.ts           # DTO for creating a courier
â”‚   â”‚       â”œâ”€â”€ update-courier.dto.ts           # DTO for updating courier info
â”‚   â”‚       â””â”€â”€ location-update.dto.ts          # DTO for updating courier location
â”‚   â”‚
â”‚   â”œâ”€â”€ notifications/                          # Email/SMS notifications
â”‚   â”‚   â”œâ”€â”€ email.service.ts                    # Service for sending emails
â”‚   â”‚   â”œâ”€â”€ sms.service.ts                      # Service for sending SMS messages
â”‚   â”‚   â”œâ”€â”€ notifications.module.ts             # NestJS module definition for notifications
â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚       â””â”€â”€ notification.dto.ts             # DTO for notification requests
â”‚   â”‚   â””â”€â”€ templates/
â”‚   â”‚       â”œâ”€â”€ welcome.hbs                     # Handlebars template for welcome email
â”‚   â”‚       â””â”€â”€ status-update.hbs               # Handlebars template for status update email
â”‚   â”‚
â”‚   â”œâ”€â”€ common/                                 # Shared utilities (guards, decorators, filters, pipes)
â”‚   â”‚   â”œâ”€â”€ guards/
â”‚   â”‚   â”‚   â”œâ”€â”€ jwt-auth.guard.ts               # Guard for protecting routes with JWT
â”‚   â”‚   â”‚   â””â”€â”€ roles.guard.ts                  # Guard for role-based access control
â”‚   â”‚   â”œâ”€â”€ decorators/
â”‚   â”‚   â”‚   â”œâ”€â”€ roles.decorator.ts              # Custom decorator for specifying roles
â”‚   â”‚   â”‚   â””â”€â”€ user.decorator.ts               # Custom decorator for extracting user from request
â”‚   â”‚   â”œâ”€â”€ filters/
â”‚   â”‚   â”‚   â””â”€â”€ http-exception.filter.ts        # Global HTTP exception filter
â”‚   â”‚   â””â”€â”€ pipes/
â”‚   â”‚       â””â”€â”€ validation.pipe.ts              # Global validation pipe for DTOs
â”‚   â”‚
â”‚   â”œâ”€â”€ prisma/                                 # Prisma ORM integration
â”‚   â”‚   â”œâ”€â”€ prisma.service.ts                   # Service for interacting with Prisma client
â”‚   â”‚   â””â”€â”€ prisma.module.ts                    # NestJS module definition for Prisma
â”‚   â”‚
â”‚   â”œâ”€â”€ config/                                 # Application configuration files
â”‚   â”‚   â”œâ”€â”€ app.config.ts                       # General app configuration
â”‚   â”‚   â”œâ”€â”€ jwt.config.ts                       # JWT configuration
â”‚   â”‚   â””â”€â”€ mail.config.ts                      # Mail service configuration
â”‚   â”‚
â”‚   â””â”€â”€ test/                                   # Test files (unit, integration, e2e)
â”‚       â””â”€â”€ ... (test files)
â”‚
â”œâ”€â”€ prisma/
â”‚   â””â”€â”€ schema.prisma                           # Prisma schema (database models and relations)
â”‚
â”œâ”€â”€ .env                                        # Environment variables
â”œâ”€â”€ .env.example                                # Example environment variables file
â”œâ”€â”€ tsconfig.json                               # TypeScript configuration
â”œâ”€â”€ package.json                                # Project dependencies and scripts
â””â”€â”€ README.md                                   # Project documentation 




Absolutely! Hereâ€™s a **step-by-step plan** to build your SendIT backend from start to finish, following the folder structure and best practices for a NestJS + Prisma + PostgreSQL project.

---

# **SendIT Backend Development Plan**

---

## **1. Project Initialization**

- **a.** Create the project folder: `sendit-backend/`
- **b.** Initialize a new NestJS project:  
  `nest new sendit-backend`
- **c.** Install dependencies:  
  - Prisma: `npm install @prisma/client`
  - Prisma CLI (dev): `npm install -D prisma`
  - Validation: `npm install class-validator class-transformer`
  - JWT Auth: `npm install @nestjs/jwt passport-jwt @nestjs/passport passport bcrypt`
  - Email: `npm install nodemailer`
  - SMS (optional): `npm install twilio` (or your preferred SMS provider)
  - Config: `npm install @nestjs/config`
- **d.** Initialize Prisma:  
  `npx prisma init`
- **e.** Set up `.env` and `prisma/schema.prisma`

---

## **2. Database Modeling (Prisma)**

- **a.** Design your `schema.prisma` with models for User, Parcel, Courier, etc.
- **b.** Run `npx prisma migrate dev --name init` to create the database and generate Prisma Client.

---

## **3. Core Module Setup**

- **a.** Create modules: `auth`, `users`, `parcels`, `couriers`, `notifications`, `common`, `prisma`, `config`
- **b.** Scaffold controllers, services, DTOs, and entities as per your folder structure.

---

## **4. Authentication Module**

- **a.** Implement registration and login endpoints.
- **b.** Use bcrypt for password hashing.
- **c.** Use JWT for authentication, with guards and strategies.
- **d.** Add DTOs for login and registration.
- **e.** Add role-based access control (user, admin, courier).

---

## **5. User Module**

- **a.** Implement CRUD for users (create, read, update, soft delete).
- **b.** Add DTOs for user creation, update, and response.
- **c.** Add guards/decorators for role-based access.

---

## **6. Parcel Module**

- **a.** Implement CRUD for parcels.
- **b.** Add endpoints for status updates and assignment to couriers.
- **c.** Add DTOs for parcel creation, update, status update, and assignment.
- **d.** Implement search and pagination for parcel lists.

---

## **7. Courier Module**

- **a.** Implement CRUD for couriers.
- **b.** Add endpoints for updating courier location and status.
- **c.** Add DTOs for courier creation, update, and location update.

---

## **8. Notifications Module**

- **a.** Implement email service (welcome, status updates).
- **b.** Implement SMS service (optional).
- **c.** Use background jobs for sending notifications (can use BullMQ or simple async for now).
- **d.** Add email templates (Handlebars or EJS).

---

## **9. Common Module**

- **a.** Implement guards (JWT, roles).
- **b.** Implement custom decorators (roles, user extraction).
- **c.** Implement global exception filters and validation pipes.

---

## **10. Config Module**

- **a.** Centralize configuration for JWT, mail, and app settings using `@nestjs/config`.

---

## **11. Prisma Module**

- **a.** Create a Prisma service and module for database access.
- **b.** Use Prisma Client in your services.

---

## **12. Testing**

- **a.** Write unit and integration tests for all modules.
- **b.** Use Jest (default with NestJS).

---

## **13. Documentation**

- **a.** Document your API endpoints (Swagger or Postman).
- **b.** Update your README with setup, usage, and environment variables.

---

## **14. Final Steps**

- **a.** Test the full backend with your Angular frontend (replace mock data with real API calls).
- **b.** Deploy your backend (Heroku, Render, DigitalOcean, etc.).
- **c.** Monitor and maintain.

---

# **Summary Table**

| Step | Task                                      | Tools/Notes                |
|------|-------------------------------------------|----------------------------|
| 1    | Project setup & dependencies              | NestJS, Prisma, JWT, etc.  |
| 2    | Database modeling                         | Prisma                     |
| 3    | Scaffold modules/folders                  | Nest CLI                   |
| 4    | Auth (JWT, bcrypt, guards, DTOs)          | @nestjs/jwt, bcrypt        |
| 5    | User CRUD, roles, soft delete             | Prisma, DTOs, guards       |
| 6    | Parcel CRUD, status, assignment           | Prisma, DTOs, search       |
| 7    | Courier CRUD, location/status             | Prisma, DTOs               |
| 8    | Notifications (email/SMS, templates)      | Nodemailer, templates      |
| 9    | Common (guards, decorators, filters)      | NestJS                     |
| 10   | Config management                         | @nestjs/config             |
| 11   | Prisma service/module                     | Prisma                     |
| 12   | Testing                                   | Jest                       |
| 13   | Documentation                             | Swagger/Postman, README    |
| 14   | Integration, deployment                   | Angular, cloud provider    |


Implement role-based guards and decorators for you?

FIST explain what you have  done like in the courier the updating location likeallyou have done in the courrier 




also for courrier shuld reeceive adiffrent emailm from the user he should receive a email saying like a parcel  of user {user email}has been assigned to you  like destination of parcel the total cost and estimated time of ensuring the parcel has arrived 

integration

Absolutely! Hereâ€™s a **step-by-step integration plan** to connect your Angular frontend to your NestJS backend, starting with authentication and moving through all core modules.

---

# ðŸ“ **Frontend-Backend Integration Plan**

---

## **1. Authentication Integration**
- **a.** Update the login/register forms to call backend `/auth/login` and `/auth/register` endpoints.
- **b.** Store the JWT token in `localStorage` or a dedicated AuthService.
- **c.** Update the AuthInterceptor to attach the JWT token to all outgoing HTTP requests.
- **d.** Update AuthGuard to check for a valid JWT and redirect to login if missing/expired.
- **e.** Update logout to clear the token and user info.

---

## **2. User Module Integration**
- **a.** Replace mock user data/services with real HTTP calls to backend `/user` endpoints.
- **b.** Fetch and display user profile and allow profile updates.
- **c.** Implement password reset flow using backend endpoints.
- **d.** Use role from JWT to control access to admin/courier/user dashboards.

---

## **3. Parcel Module Integration**
- **a.** Replace mock parcel data/services with real HTTP calls to backend `/parcel` endpoints.
- **b.** Implement create, update, delete, and status update flows.
- **c.** Fetch and display sent/received parcels for users.
- **d.** Fetch and display assigned parcels for couriers.
- **e.** Implement parcel search, filter, and pagination using backend support.

---

## **4. Courier Module Integration**
- **a.** Replace mock courier data/services with real HTTP calls to backend `/courier` endpoints.
- **b.** Implement courier location updates (with reverse geocoding).
- **c.** Fetch and display courier analytics, stats, and assigned parcels.
- **d.** Allow admin to manage couriers.

---

## **5. Address & Geocoding Integration**
- **a.** Use backend `/address` endpoints for address CRUD and geocoding.
- **b.** Use backend for distance calculation and pricing estimation.

---

## **6. Notification Integration**
- **a.** Fetch notifications from backend `/notifications` endpoint.
- **b.** Mark notifications as read/unread, delete, etc.
- **c.** Display notification count and details in the UI.

---

## **7. Real-Time (WebSocket) Integration**
- **a.** Connect to backend WebSocket for live parcel/courier updates.
- **b.** Subscribe to location and status events for real-time tracking.
- **c.** Update UI in real-time as events are received.

---

## **8. Error Handling & UX Polish**
- **a.** Add global error handling for HTTP and WebSocket errors.
- **b.** Show user-friendly error/success messages.
- **c.** Handle loading states and empty data gracefully.

---

## **9. Final Testing & QA**
- **a.** Test all flows end-to-end (auth, parcel, courier, notifications, etc.).
- **b.** Test with different user roles (admin, courier, user).
- **c.** Test on different devices and browsers.

---

# **Recommended Order**
1. **Authentication**
2. **User Module**
3. **Parcel Module**
4. **Courier Module**
5. **Address/Geocoding**
6. **Notifications**
7. **Real-Time/WebSocket**
8. **Error Handling & UX**
9. **Final Testing**

---




import { Component, OnInit } from '@angular/core';
import { ParcelService } from '../../core/services/parcel';
import { Parcel } from '../../shared/models/parcel.model';
import { ModalComponent } from '../../shared/components/modal/modal.component';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-user-dashboard',
  templateUrl: './dashboard.html',
  styleUrls: ['./dashboard.css'],
  standalone: true,
  imports: [CommonModule, ModalComponent, FormsModule]
})
export class UserDashboardComponent implements OnInit {
  parcels: Parcel[] = [];
  userEmail: string | null = null;
  error: string | null = null;
  loading = false;
  searchTerm: string = '';
  activity: any[] = [];
  filteredActivity: any[] = [];
  stats = [
    { title: 'Sent Parcels', number: 0, icon: 'sent-icon', change: 0 },
    { title: 'Received Parcels', number: 0, icon: 'received-icon', change: 0 },
    { title: 'In Transit', number: 0, icon: 'intransit-icon', change: 0 },
    { title: 'Delivered', number: 0, icon: 'delivered-icon', change: 0 }
  ];

  constructor(private parcelService: ParcelService) {}

  ngOnInit() {
    const userStr = localStorage.getItem('sendit_user');
    if (userStr) {
      const user = JSON.parse(userStr);
      console.log("ðŸ” Current user email:", this.userEmail);
      this.userEmail = user.email;
    }
    this.loading = true;
    this.error = null;
    this.parcelService.getParcels().subscribe({
      next: (parcels) => {
        console.log("ðŸ“¦ All parcels fetched:", parcels);
        console.log("ðŸ“¦ Number of parcels:", parcels.length);
        
        this.parcels = this.userEmail
          ? parcels.filter(p => 
              (p.senderEmail === this.userEmail || p.receiverEmail === this.userEmail) ||
              (typeof p.sender === 'string' && p.sender === this.userEmail) ||
              (typeof p.receiver === 'string' && p.receiver === this.userEmail)
            )
          : [];
        // For demo: populate activity from parcels
        this.activity = this.parcels.map(p => ({
          trackingId: p.id,
          recipient: typeof p.receiver === 'string' ? p.receiver : p.receiverEmail || 'Unknown',
          status: p.status,
          statusClass: p.status === 'DELIVERED' ? 'delivered' : (p.status === 'IN_TRANSIT' ? 'in-transit' : 'pending'),
          date: p.updatedAt || p.createdAt || new Date()
        }));
        this.filteredActivity = [...this.activity];

        // Calculate real statistics from fetched data
        this.calculateStats();
        this.loading = false;
    const sentParcels = this.parcels.filter(p => p.sender?.email === this.userEmail);
    
    const receivedParcels = this.parcels.filter(p => p.receiver?.email === this.userEmail);
  }


  calculateStats() {
    if (!this.userEmail) return;

    const sentParcels = this.parcels.filter(p => 
      p.senderEmail === this.userEmail || 
      (typeof p.sender === "string" && p.sender === this.userEmail)
    );
    
    const receivedParcels = this.parcels.filter(p => 
      p.receiverEmail === this.userEmail || 
      (typeof p.receiver === "string" && p.receiver === this.userEmail)
    );

    const inTransitParcels = this.parcels.filter(p => p.status === "IN_TRANSIT");
    const deliveredParcels = this.parcels.filter(p => p.status === "DELIVERED");

    // Update stats with real data
    this.stats = [
      { 
        title: "Sent Parcels", 
        number: sentParcels.length, 
        icon: "sent-icon", 
        change: 0 
      },
      { 
        title: "Received Parcels", 
        number: receivedParcels.length, 
        icon: "received-icon", 
        change: 0 
      },
      { 
        title: "In Transit", 
        number: inTransitParcels.length, 
        icon: "intransit-icon", 
        change: 0 
      },
      { 
        title: "Delivered", 
        number: deliveredParcels.length, 
        icon: "delivered-icon", 
        change: 0 
      }
    ];
  }

  filterActivity() {
    this.filteredActivity = this.activity.filter(a =>
      a.trackingId.toLowerCase().includes(this.searchTerm.toLowerCase()) ||
      a.recipient.toLowerCase().includes(this.searchTerm.toLowerCase())
    );
  }

  viewParcel(activity: any) {
    // Implement modal or navigation to parcel details
    alert('View Parcel: ' + activity.trackingId);
  }

  trackParcel(activity: any) {
    // Implement navigation to track parcel page
    alert('Track Parcel: ' + activity.trackingId);
  }

  logout() {
    localStorage.removeItem('sendit_user');
    window.location.href = '/';
  }
} 